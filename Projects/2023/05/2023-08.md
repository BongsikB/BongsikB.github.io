## <p align="center"> 📆 8/8</p>

### 객체지향 OOP

- 클래스 + 오브젝트 = 청사진 | 템플릿
- 객체 = 클래스의 인스턴스
- 캡슐화
  - 연관 있는 함수(메소드), 데이터를 묶는 것
  - e.g. 💊 감기약
  - e.g. 고양이의 기분(state)를 변경할 수 있음
- 추상화
  - 내부의 복잡한 기능을 모두 이해하지 않고, `간단한 외부 인터페이스`로 사용하는 것
  - e.g. 커피머신의 내부를
- 상속(재사용)
  - 새로운 클래스(하위 or 파생클래스)가 기존 클래스(상위 or 기본 클래스)의 특성과 동작을 상속
    - parent - child
    - super - sub
    - base - derived
  - 코드 재사용을 촉진, 클래스간`IS-A 관계`
- 다형성
  - 서로 다른 클래스의 객체들을 상위 클래스 객체로 다를 수 있는 것
  - 하나의 인터페이스로 다양한 구현을 나타낼 수 있음

## <p align="center"> 📆 8/12</p>

### 💎 Static

```
1. 인스턴스 생성없이 접근 가능
2. 인스턴스와 공유
클래스 수준의 데이터나 동작 관리
```

- 정적멤버 정의
  - e.g. `Math.abs()`
  - Math개체의 정적 메소드
  - 클래스의 이름을 통해 바로 호출
    - 즉, 클래스의 인스턴스화 필요 X

### 🏗️ constructor

- 인스턴스를 반들 때 호출되는 함수

### `this`

- 클래스안의 멤버에 접근하기 위함

### getter & setter

- `getter`: 클래스 내부멤버 `변수`를 가져옴
- `setter`: 클래스 내부멤버 `변수값`을 가져옴

### 💊 캡슐화

- 정보 은닉

### 🎑 추상화 == `단순성`

- 클래스의 간편화
- 어떻게 꾸며야 하는지 등을 설정

## <p align="center"> 📆 8/13</p>

### get, set 학습

~중복된 코드가 있지만, 좋은 학습이었다~

```typescript
class Convertor {
  private _input: string;

  constructor(input: string) {
    this._input = input;
  }

  get stringValue(): string {
    return this._input;
  }

  set stringValue(value: string) {
    this._input = value;
  }

  get lowercaseValue(): string {
    if (typeof this._input === "string") {
      return this._input.toLowerCase();
    } else {
      return "value should be string";
    }
  }

  set lowercaseValue(value: string) {
    this._input = value.toLowerCase();
  }

  get uppercaseValue(): string {
    if (typeof this._input === "string") {
      return this._input.toUpperCase();
    } else {
      return "value should be 'string'";
    }
  }

  set uppercaseValue(value: string) {
    this._input = value.toUpperCase();
  }
}

const input = new Convertor("hi today is Sunday");
console.log(input.stringValue);
console.log(input.uppercaseValue);
console.log(input.lowercaseValue);
```
