## <p align="center"> 📆 8/8</p>

### 객체지향 OOP

- 클래스 + 오브젝트 = 청사진 | 템플릿
- 객체 = 클래스의 인스턴스
- 캡슐화
  - 연관 있는 함수(메소드), 데이터를 묶는 것
  - e.g. 💊 감기약
  - e.g. 고양이의 기분(state)를 변경할 수 있음
- 추상화
  - 내부의 복잡한 기능을 모두 이해하지 않고, `간단한 외부 인터페이스`로 사용하는 것
  - e.g. 커피머신의 내부를
- 상속(재사용)
  - 새로운 클래스(하위 or 파생클래스)가 기존 클래스(상위 or 기본 클래스)의 특성과 동작을 상속
    - parent - child
    - super - sub
    - base - derived
  - 코드 재사용을 촉진, 클래스간`IS-A 관계`
- 다형성
  - 서로 다른 클래스의 객체들을 상위 클래스 객체로 다를 수 있는 것
  - 하나의 인터페이스로 다양한 구현을 나타낼 수 있음

## <p align="center"> 📆 8/12</p>

### 💎 Static

```
1. 인스턴스 생성없이 접근 가능
2. 인스턴스와 공유
3. 클래스 수준의 데이터나 동작 관리
```

- 정적멤버 정의
  - e.g. `Math.abs()`
  - Math개체의 정적 메소드
  - 클래스의 이름을 통해 바로 호출
    - 즉, 클래스의 인스턴스화 필요 X

### 🏗️ constructor

- 인스턴스를 반들 때 호출되는 함수

### `this`

- 클래스안의 멤버에 접근하기 위함

### getter & setter

- `getter`: 클래스 내부멤버 `변수`를 가져옴
- `setter`: 클래스 내부멤버 `변수값`을 가져옴

### 💊 캡슐화

- 정보 은닉

### 🎑 추상화 == `단순성`

- 클래스의 간편화
- 어떻게 꾸며야 하는지 등을 설정

## <p align="center"> 📆 8/13</p>

### get, set 학습

~중복된 코드가 있지만, 좋은 학습이었다~

```typescript
class Convertor {
  private _input: string;

  constructor(input: string) {
    this._input = input;
  }

  get stringValue(): string {
    return this._input;
  }

  set stringValue(value: string) {
    this._input = value;
  }

  get lowercaseValue(): string {
    if (typeof this._input === "string") {
      return this._input.toLowerCase();
    } else {
      return "value should be string";
    }
  }

  set lowercaseValue(value: string) {
    this._input = value.toLowerCase();
  }

  get uppercaseValue(): string {
    if (typeof this._input === "string") {
      return this._input.toUpperCase();
    } else {
      return "value should be 'string'";
    }
  }

  set uppercaseValue(value: string) {
    this._input = value.toUpperCase();
  }
}

const input = new Convertor("hi today is Sunday");
console.log(input.stringValue);
console.log(input.uppercaseValue);
console.log(input.lowercaseValue);
```

## <p align="center"> 📆 8/13</p>

### `env.local`

- 로컬 서버로 시작하게 됨
- gitignore에 `env*.local` 등록하여 사용

### Typescript

- 인터페이스: 커피 메이커의 동작 규약
- 추상화: 커피 머신을 나타내는 추상 클래스

```typescript
// 추상화: 커피 머신을 나타내는 추상 클래스
abstract class AbstractCoffeeMachine {
  protected coffeeBeans: number = 0;

  constructor(coffeeBeans: number) {
    this.coffeeBeans = coffeeBeans;
  }

  protected abstract grindBeans(shots: number): void;
  protected abstract preheat(): void;
  protected abstract extract(shots: number): CoffeeCup;

  makeCoffee(shots: number): CoffeeCup {
    this.grindBeans(shots);
    this.preheat();
    return this.extract(shots);
  }

  fillCoffeeBeans(beans: number) {
    if (beans < 0) {
      console.log("value for beans should be greater than 0");
    }
  }
}

// 인터페이스: 커피 메이커의 동작 규약
interface CoffeeMaker {
  makeCoffee(shots: number): CoffeeCup;
}

class CoffeeMachine extends AbstractCoffeeMachine implements CoffeeMaker {
  private static BEANS_GRAM_PER_SHOT: number = 7;

  constructor(coffeeBeans: number) {
    super(coffeeBeans);
  }

  static makeMachine(coffeeBeans: number): CoffeeMachine {
    return new CoffeeMachine(coffeeBeans);
  }

  protected grindBeans(shots: number) {
    console.log(`grinding beans for ${shots}`);
    if (this.coffeeBeans < shots * CoffeeMachine.BEANS_GRAM_PER_SHOT) {
      console.log("not enough coffee");
    }
    this.coffeeBeans -= shots * CoffeeMachine.BEANS_GRAM_PER_SHOT;
  }

  protected preheat(): void {
    console.log("heating up...!");
  }

  protected extract(shots: number): CoffeeCup {
    console.log(`pulling ${shots} shots...`);
    return {
      shots,
      hasMilk: false,
    };
  }
}

// 커피 머신 인스턴스 생성 및 사용
const maker: CoffeeMachine = CoffeeMachine.makeMachine(32);
maker.fillCoffeeBeans(32);
maker.makeCoffee(2);
```
